const { get } = require("server/router");
const { type } = require("server/reply");
const { build } = require("esbuild");
const { isAbsolute, join } = require("path");
const fs = require("mz/fs");
const { promisify } = require("util");

// The text for the file already exists
const fileExists = name => `
There is already a file called ${name} that was not created by @server/esm.
Make sure to remove or rename this file, since @server/esm uses this file to put the bundled JS.
`;

// Async renderer file => string
const render = async (file, opts = {}) => {
  const entryPoints = [file];
  const res = await build({ entryPoints, bundle: true, write: false, ...opts });
  const text = new TextDecoder("utf-8").decode(res.outputFiles[0].contents);
  return "/* @server/esm */\n" + text;
};

// Render to a single JS file
const renderFile = async (file, destination, opts = {}) => {
  const js = await render(file, opts);
  await fs.writeFile(destination, js, "utf8");
};

const removeFile = async path => {
  if (await fs.exists(path)) {
    // Throw if this file was not autogenerated
    if (!/\/\* @server\/esm/.test(await fs.readFile(path))) {
      throw new Error(fileExists(path));
    }

    await fs.unlink(path);
  }
};

module.exports = {
  name: "esm",
  options: {
    __root: "source",
    source: {
      default: "scripts/index.js",
      clean: value => (isAbsolute(value) ? value : join(process.cwd(), value))
    }
  },

  // Write the file in the right place
  init: async ctx => {
    // Generate the path within the public folder
    const toPublic = file => join(ctx.options.public, file);

    // Delete the OUTPUT/BUNDLED files for any environment on startup
    await Promise.all([
      removeFile(toPublic("script.js")),
      removeFile(toPublic("script.min.js"))
    ]);

    // In production, write it to the public path so that the requests hit
    // the public folder straight away without going through middleware
    if (ctx.options.env === "production") {
      const source = ctx.options.esm.source;
      await Promise.all([
        renderFile(source, toPublic("script.js"), { minify: false }),
        renderFile(source, toPublic("script.min.js"), { minify: true })
      ]);
    }
  },

  before: [
    get("/script.js", async ctx => {
      // Create the expanded js and send it to the front-end
      const js = await render(ctx.options.esm.source, { minify: false });
      return type("text/javascript").send(js);
    }),

    get("/script.min.js", async ctx => {
      // Create the minified js and send it to the front-end
      const js = await render(ctx.options.esm.source, { minify: true });
      return type("text/javascript").send(js);
    })
  ]
};
